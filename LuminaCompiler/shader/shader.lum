// Include predefined and user-provided files
import "lumina/screenConstants" /* invalid */
import "shader/customInclude.lum"

// Define the pipeline flow
Input -> VertexPass: Vector3 vertexPosition;
Input -> VertexPass: Vector3 vertexNormal;
Input -> VertexPass: Vector2 vertexUV;
VertexPass -> FragmentPass: Vector3 fragPosition;
VertexPass -> FragmentPass: Vector3 fragNormal;
VertexPass -> FragmentPass: Vector2 fragUV;

// Define custom structures
struct Material
{
    Vector3
    _diffuseColor;
    Vector3 /* Test */ _specularColor;
    float _shininess;
};

// Define a texture
Texture diffuseTexture /*test*/;

// Define attribute blocks
AttributeBlock/*test*/ modelAttributes/*test*/
{
//test
    Matrix4x4 modelMatrix = /*test*/ Matrix4x4();
    Matrix4x4 /*test*/ normalMatrix/*test*/ ;
    /*test*/
}/*test*/;

// Define constant blocks
ConstantBlock /*test*/lightingConstants/*test*/
{
    Vector3 /*test*/lightPosition = Vector3(test(10), 10.0/*test*/, 10.0) /*test*/+ Vector3(10.0, 10.0/*test*/, 10.0);/*test*/
    Vector3 lightColor = /*test*/Vector3(1.0);
    float ambientIntensity = 0.1 + 15.0/*test*/;
}/*test*/;

    Vector3 /*test*/ calculateDiffuse(/**/Vector3 normal/*test*/, Vector3 lightDir, /*test */ Vector3 lightColor /**/)
    {
		if ( /*test*/ true /*test*/ )
		{
			float/*test*/ test;
			float test2 =/*test*/ test + 1;
		}
        float diff = max(/*test*/dot(normal, /*test*/lightDir), /*test*/0.0);
        /*test*/return diff /*test*/ * /*test*/ lightColor;
    }

/* Create namespaces
with multiline comments */
namespace Lighting
{

	/*test*/ 
	
	struct Information
	{
		float test;
	};
	/*test*/ 
	Texture default;

	AttributeBlock RenderingInfo
	{/*test*/ 
		float test;/*test*/ 
	}/*test*/ ;/*test*/ 

	ConstantBlock Intencity
	{
		Vector3 lightPosition = Vector3(10.0, 10.0, 10.0);
	}/*test*/ ;

    /*test*/ Vector3 calculateDiffuse(Vector3 normal, Vector3 lightDir, Vector3 lightColor) /*test*/ 
    {
        float diff = max(dot(normal, lightDir), 0.0);
        return diff * lightColor;
    }/*test*/ 

    Vector3 calculateSpecular(Vector3 normal, Vector3 lightDir, Vector3 viewDir, float shininess, Vector3 lightColor)
    {
        Vector3 reflectDir = reflect(-lightDir, normal);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
        return spec * lightColor;
    }/*test*/ 
}/*test*/ 

// Define the vertex shader stage
VertexPass()
{
    Vector4 worldPosition = modelAttributes.modelMatrix * Vector4(vertexPosition, 1.0);
    fragPosition = worldPosition.xyz;
    fragNormal = mat3(modelAttributes.normalMatrix) * vertexNormal;
    fragUV = vertexUV;

    Vector4 clipSpacePosition = screenConstants.canvasMVP * worldPosition;
    pixelPosition = clipSpacePosition;
}

// Define the fragment shader stage
FragmentPass()
{
    // Error handling example
    if (lightingConstants.ambientIntensity < 0.0 || lightingConstants.ambientIntensity > 1.0)
    {
        raiseException("Ambient intensity must be between 0 and 1. Current value: %d", lightingConstants.ambientIntensity);
    }

    Vector3 normal = normalize(fragNormal);
    Vector3 lightDir = normalize(lightingConstants.lightPosition - fragPosition);
    Vector3 viewDir = normalize(-fragPosition);

    Vector3 ambient = lightingConstants.ambientIntensity * lightingConstants.lightColor;

	for (int i = 0; i < 4; i++)
	{
		Vector3 test = Vector3(10, 11, 12);
	}

    Vector3 diffuse = Lighting::calculateDiffuse(normal, lightDir, lightingConstants.lightColor);

    Material material;
    Vector3 specular = Lighting::calculateSpecular(normal, lightDir, viewDir, material._shininess, lightingConstants.lightColor);

    Vector3 finalColor = ambient + diffuse * material._diffuseColor + specular * material._specularColor;

    Vector4 textureColor = diffuseTexture.pixel(fragUV);
    finalColor *= textureColor.rgb;

    if (textureColor.a == 0)
    {
        discard;
    }

    pixelColor = Vector4(finalColor, textureColor.a);
}