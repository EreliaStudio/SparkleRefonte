

import "lumina/screenConstants" 


import "shader/customInclude.lum" 


Input -> VertexPass : Vector3 vertexPosition ; 

Input -> VertexPass : Vector3 vertexNormal ; 

Input -> VertexPass : Vector2 vertexUV ; 

VertexPass -> FragmentPass : Vector3 fragPosition ; 

VertexPass -> FragmentPass : Vector3 fragNormal ; 

VertexPass -> FragmentPass : Vector2 fragUV ; 


struct Material 
{ 
    Vector3 _diffuseColor ; 
    Vector3 _specularColor ; 
    float _shininess ; 
} ; 


Texture diffuseTexture ; 


AttributeBlock modelAttributes 
{ 
    Matrix4x4 modelMatrix = Matrix4x4 ( ) ; 
    Matrix4x4 normalMatrix ; 
} ; 


ConstantBlock lightingConstants 
{ 
    Vector3 lightPosition = Vector3 ( test ( 10 ) , 10.0 , 10.0 ) + Vector3 ( 10.0 , 10.0 , 10.0 ) ; 
    Vector3 lightColor = Vector3 ( 1.0 ) ; 
    float ambientIntensity = 0.1 + 15.0 ; 
} ; 

Vector3 calculateDiffuse ( Vector3 normal , Vector3 lightDir , Vector3 lightColor ) 
{ 
    if ( true ) 
    { 
        float test ; 
        float test2 = test + 1 ; 
    } 
    float diff = max ( dot ( normal , lightDir ) , 0.0 ) ; 
    return diff * lightColor ; 
} 


namespace Lighting 
{ 
    struct Information 
    { 
        float test ; 
    } ; 
    Texture default ; 
    AttributeBlock RenderingInfo 
    { 
        float test ; 
    } ; 
    ConstantBlock Intencity 
    { 
        Vector3 lightPosition = Vector3 ( 10.0 , 10.0 , 10.0 ) ; 
    } ; 
    Vector3 calculateDiffuse ( Vector3 normal , Vector3 lightDir , Vector3 lightColor ) 
    { 
        float diff = max ( dot ( normal , lightDir ) , 0.0 ) ; 
        return diff * lightColor ; 
    } 
    Vector3 calculateSpecular ( Vector3 normal , Vector3 lightDir , Vector3 viewDir , float shininess , Vector3 lightColor ) 
    { 
        Vector3 reflectDir = reflect ( - lightDir , normal ) ; 
        float spec = pow ( max ( dot ( viewDir , reflectDir ) , 0.0 ) , shininess ) ; 
        return spec * lightColor ; 
    } 
} 



VertexPass ( ) 
{ 
    Vector4 worldPosition = modelAttributes . modelMatrix * Vector4 ( vertexPosition , 1.0 ) ; 
    fragPosition = worldPosition . xyz ; 
    fragNormal = mat3 ( modelAttributes . normalMatrix ) * vertexNormal ; 
    fragUV = vertexUV ; 
    Vector4 clipSpacePosition = screenConstants . canvasMVP * worldPosition ; 
    pixelPosition = clipSpacePosition ; 
} 


FragmentPass ( ) 
{ 
    if ( lightingConstants . ambientIntensity < 0.0 || lightingConstants . ambientIntensity > 1.0 ) 
    { 
        raiseException ( "Ambient intensity must be between 0 and 1. Current value: %d" , lightingConstants . ambientIntensity ) ; 
    } 
    Vector3 normal = normalize ( fragNormal ) ; 
    Vector3 lightDir = normalize ( lightingConstants . lightPosition - fragPosition ) ; 
    Vector3 viewDir = normalize ( - fragPosition ) ; 
    Vector3 ambient = lightingConstants . ambientIntensity * lightingConstants . lightColor ; 
    for ( int i = 0 ; i < 4 ; i ++ ) 
    { 
        Vector3 test = Vector3 ( 10 , 11 , 12 ) ; 
    } 
    Vector3 diffuse = Lighting :: calculateDiffuse ( normal , lightDir , lightingConstants . lightColor ) ; 
    Material material ; 
    Vector3 specular = Lighting :: calculateSpecular ( normal , lightDir , viewDir , material . _shininess , lightingConstants . lightColor ) ; 
    Vector3 finalColor = ambient + diffuse * material . _diffuseColor + specular * material . _specularColor ; 
    Vector4 textureColor = diffuseTexture . pixel ( fragUV ) ; 
    finalColor * = textureColor . rgb ; 
    if ( textureColor . a == 0 ) 
    { 
        discard ; 
    } 
    pixelColor = Vector4 ( finalColor , textureColor . a ) ; 
} 
